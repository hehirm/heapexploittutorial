---
title: Zero To Hero
layout: default
nav_order: 2
parent: Exploits
---
# Zero To Hero
### Challenge Description

- **CTF Name:** picoCTF 2019
- **Challenge Name:** zero_to_hero
- **Challenge Category:** Binary Exploitation
- **Challenge Points:** 500

zero_to_hero is a heap exploitation challenge from picoCTF 2019. The challenge description reads:

> Now you're really cooking. Can you pwn this service? Connect with 

### Preparing the Binary

The challenge includes the libc and dynamic linker used to execute the binary. Make sure that these files are downloaded to the same directory as the executable. The binary needs to be patched to use the dynamic linker supplied in the challenge. This can be done by using the `patchelf` command as follows:

```
> patchelf --set-interpreter ld-2.29.so zero_to_hero
```

Make sure to also allow executable permissions on the binary and dynamic linker:

```
> chmod +x zero_to_hero
> chmod +x ld-2.29.so
```

### Initial observations

Running the binary reveals the following prompt and waits for user input:

```
From Zero to Hero
So, you want to be a hero?

```

In putting the string "a" gives the following answer before exiting:

```
No? Then why are you even here?
```

Executing the binary again and instead entering "yes" at the prompt produces an options menu:

```
Really? Being a hero is hard.
Fine I see I can't convince you otherwise.
It's dangerous to go alone. Take this: 0x7f2df55defd0
1. Get a superpower
2. Remove a superpower
3. Exit
> 
```

The address on line 3 looks interesting - we will look into what it is in a moment.

Entering 1 into the prompt allows us to specify the length of a superpower, and the superpower itself as a string.

```
Describe your new power.
What is the length of you description?
> 6
Enter your description:
> flying
Done!
```

Playing around with this, we can enter up to 7 superpowers - any more than this gives an error message and terminates the program.

Entering 2 into the prompt produces the following output:

```
Which power would you like to remove?
> 
```

Entering the name of the superpower in some cases causes the program to crash. We will see the cause of this in the next section. Specifying option 3 terminates the program as expected.
### Decompiling and Analysing

Lets get a better idea of whats happening here by decompiling the binary. Using Ghidra, we get the following output:

Up to line 23 seems to be the code corresponding to the initial "So you want to be a hero?" prompt. There is no buffer overflow here. We can also see that the program only checks if the first character is "y", so we will enter that from now on.

The core of the program is the two while loops spanning from line 27 to the end of the program. Exploring `FUN_00400997();` reveals that it is the function that prints the 3 options available to us. The option specified by the user is read into the variable local_2c.

If the option read is `3` then control ends up at line 41, printing "Giving up?" before exiting. If option `2` is read (corresponding to removing a power), the program executes `FUN_00400bb3();`. The Ghidra analysis of this function is:


We can now see why removing a power was causing the program to crash - the program was expecting an index instead of a name. The call to `free();` uses this index to access a particular pointer to remove. The last lines before returning is a stack canary, which hopefully shouldn't matter to us.

Going back and considering the case where option `1` is read, the program ends up at `FUN_00400a4d();`. Lines 16 though 19 determine if too many powers have been asked for, based on the value of `local_24`, which is set according to the function `FUN_004009c2();` exploring this function (and recalling our experience interacting with the program). The maximum number of superpowers we can have is 6. The function then reads in the size of the power in to `local_28`, which has an upper limit of `0x408`. The function then allocates some memory to store our power with the call to the `malloc();` function:

```
pvVar2 = malloc((ulong)local_28)
```

The pointer returned then seems to be stored in some kind of array on the next line (this is used by other functions to determine the number of powers allocated). We are now reaching the vulnerable section of the binary - pay attention now! The program prompts the user to enter the power description, which will be stored in the memory previously set aside by the call to `malloc();`. `lVar1` stores the pointer returned by malloc i.e. the address where we want to write the power description. The next line actually reads the user input into the memory set aside. Lets break down how this is happening:

```
sVar3 = read(0,*(void **)(&DAT_00602060 + (long)local_24 * 8),(ulong)local_28);
```

Looking at the Linux man page for the `read();` function shows us the following function prototype:

```
ssize_t read(int fd, void *buf, size_t count);
```

- `fd` stands for file descriptor, and specifies where the data is coming from. An `fd` of `0` indicated that the input is coming from standard input i.e. input from the keyboard.
- `*buf` is the starting address of where our data will be stored. In this case, we are passing in the address returned by `malloc();`, although we are grabbing it from the array.
- `count` specifies the maximum number of bytes to read. In this case it has been set to the value of `local_28`, or the number specified by the user.
- The function **returns the number of bytes read**. Since we can read up to `count` bytes, the maximum number this can be is the size that we specified in `local_28`. Since `malloc();` only reserved this many bytes, we are potentially filling up the buffer.

Now comes the kicker - lets have a look at the next line:

```
*(undefined *)(sVar3 + lVar1) = 0;
```

Since `sVar3` stores the starting address of the power description, and `lVar1` stores the number of bytes read from the user input, this line is appending a newline at the end of the power description. This is common practice, as a null byte indicates the termination of a string. However, since the buffer is completely full **this null byte is not contained in the buffer allocated by malloc** i.e. we have a **single null byte overflow**. This diagram should hopefully clarify the situation - the user specified 6 bytes for the power description and entered the string "flying" which contains exactly 6 bytes:

```
Reserved                Overflow
+---+---+---+---+---+---+----+
| f | l | y | i | n | g | \0 |
+---+---+---+---+---+---+----+
```

The null byte now exists in a region of memory that was not reserved by malloc, and could potentially be in use by another part of the program - overwriting it could (and will) lead to a vulnerability.

### Running the program with GDB

Remember the address that we found in our initial experimentation with the program? Lets use GDB to figure out its meaning. We can start the program with GDB using the command:

```
gdb zero_to_hero
```

Next we need to figure out where to set a breakpoint. Looking at the Ghidra output, line 30 seems to be a good place to stop, which has address `0x00400d6f`. We can set the breakpoint using the command `break *0x400d6f`. The program can then be run, using the command `run` (make sure to answer "y" to the prompt to reach the breakpoint).

Scrolling back through the output, we can find where the program tells us the address. We see that the value is `0x7ffff7e31fd0`. In fact this is a lie - you most likely won't see this value. This value is also different to the one displayed in the opening section. Whats going on? The short answer is Address Space Layout Randomisation (ASLR), which is the randomisation of the base address of key memory locations such as the heap, stack and libraries. It is an exploit prevention mechanism, as attackers can no longer memorise the addresses of these key memory locations. For now, having an awareness that this is occurring is enough, although I encourage you to learn more about it if you are interested.

Lets examine the memory contents at this location. We can do this by entering the following command into the GDB prompt

```
hexdump bytes --size 100 0x7ffff7e31fd0
```

`hexdump bytes` produces a dump of bytes. The size flag specifies the number of bytes (in this case 100). The address specifies the starting location for the dump. The command produces the following output:

```

```

Immediately our attention should be drawn to the `<system+0000>` section - this address contains the `system()` function from the C standard library. The `system()` function allows us to execute a shell command, including the ability to launch a shell. However this is not the only thing this address has given us - if we take the difference of this address and the offset of the `system()` function in the C standard library, we can find the base address of the C standard library, essentially giving us the address of any function in the library (provided we know the offset from the base address). This will be extremely useful to us in crafting the exploit.

We can now close the GDB session with the `exit` command.
### Understanding the exploit

We are going to use the null byte overflow found in the preceding section to write an exploit that allows us to launch a shell, where we should hopefully be able to find the flag. In order to do this we need to review some important details about the program.

The first is that the overflow occurs in a buffer allocated by the heap, meaning that our exploit is going to leverage vulnerabilities in heap management. This should not be a surprise - this is a heap exploitation tutorial after all.

The second is that the user is only permitted to have 6 powers. This means that all memory deallocations are **exclusively sent to the tcache bin**. Thus, our exploit is going to rely on vulnerabilities in tcache management. Specifically, we are going to use the null byte overflow to cause a **double free** - a situation where the same area of memory is freed twice. With a double free we will be able to modify the contents of a freed chunk to point to the `free_hook()` function, which will allow us to get a shell.

For the remainder of this section we will speak generally in terms of allocating and freeing chunks as opposed to adding and removing powers, although the null byte overflow is still assumed.

Let us allocate a chunk which we will refer to as Chunk 1. The size of this chunk must be such that chunk aligning places the next chunk header directly after this chunk. `0x48` will work. The contents are unimportant. Next we allocate a second chunk, Chunk 2. The contents of this chunk are unimportant, but the size is - it must be larger than `0x100` in order for the overflow to have an effect. We will arbitrarily choose `0x120`. The state of the heap currently is:

```
Chunk 1   Chunk 2              Top Chunk
+---------+--------------------+------------+
| 0x48    | 0x120              |            |
+---------+--------------------+------------+
|         |                    |            |
+---------+--------------------+------------+
```

Let us now deallocated Chunk 2 followed by Chunk 1. The chunks will now be placed in the tcache bins, Chunk 2 going to the `0x120` tcache bin, and Chunk 1 going to the `0x40` tcache bin. The current heap state will be:


```
Chunk 1   Chunk 2              Top Chunk
+---------+--------------------+------------+
| 0x48    | 0x120              |            |
+---------+--------------------+------------+
|         |                    |            |
+---------+--------------------+------------+

tcache[0x48] -> Chunk 1
tcache[0x120] -> Chunk 2
```

Now we will reallocate Chunk 1, this time giving it the string "/bin/sh\\x00" followed by enough A's to force the null overflow (the reason for using this particular string will become apparent later). Recall that the chunks size is a byte value stored at the beginning of the chunk header, a region of 16 bytes preceding the chunk data. Integers are also stored in little endian, meaning the least significant bits are stored first. Since Chunk 1 and Chunk 2 are contiguous (as shown in the diagram), the null byte overflow occurring in Chunk 1 causes the size field of Chunk 2 to be modified. The following diagram shows the new scenario:

```
Chunk 1       Chunk 2              Top Chunk
+-------------+--------------------+------------+
| 0x40        | 0x100              |            |
+-------------+--------------------+------------+
| /bin/sh\x00 |                    |            |
+-------------+--------------------+------------+

tcache[0x120] -> Chunk 2
```

Notice that Chunk 2 now has a size field of `0x100` but is stored in the tcache bin for chunks of size `0x120`. This means we can now free chunk 2 again, resulting in it being placed into the tcache bin for chunks of size `0x100`.

```
Chunk 1       Chunk 2              Top Chunk
+-------------+--------------------+------------+
| 0x40        | 0x100              |            |
+-------------+--------------------+------------+
| /bin/sh\x00 |                    |            |
+-------------+--------------------+------------+

tcache[0x100] -> Chunk 2
tcache[0x120] -> Chunk 2
```

Now we allocate a chunk of size `0x120`. Since the tcache contains a pointer to a chunk of this size, it will be used to service the request. We will set the contents of the chunk to contain the address of the `*__free_hook()` function pointer from the C standard library.

We will take a slight deviation to discuss the `*__free_hook()` function pointer in more detail. Often it is useful for debugging purposes to produce a log of each call to `malloc` and `free` to determine if a program has a memory leak. This can be achieved by using a malloc hook and free hook respectively. These hooks point to functions that are to be executed on every call to malloc or free (depending on the type of hook). The relevant function pointer for a free hook is `*__free_hook()`, and has prototype:

```
void (*__free_hook)(void *ptr, const void *caller)
```

When changing the value of the function pointer usually we would make sure that the prototype of the new function has the same arguments.

So what is achieved by setting this to be the contents of the allocated chunk? The chunk that has been used to service the request is Chunk 2, as this was the chunk pointed to by the `0x120` tcache. However Chunk 2 is also pointed to by the `0x100` tcache as a result of our double free. Recall that the section normally used for housing data in a chunk is repurposed for freed chunks in the tcache to store pointers to the next and previous free chunks of that size. Setting the data as we have overwrites the pointer to the next free chunk to the address of `*__free_hook()`.

Lets look at a diagram to summarise whats happening:

```
Chunk 1       Chunk 2              Top Chunk
+-------------+--------------------+------------+
| 0x40        | 0x100              |            |
+-------------+--------------------+------------+
| /bin/sh\x00 | 0xf73ea9           |            |
+-------------+--------------------+------------+

0xf73ea9 (__free_hook location)
+-------------+
|             |
+-------------+

tcache[0x100] -> Chunk 2 -> 0xf73ea9
```

We now allocate another chunk of size 0x100, the contents of the chunk being unimportant. Since Chunk 2 is in the `0x100` tcache it is used for the allocation. Further, since the next pointer points to the `*__free_hook()` location, this address remains in the tcache.

```
Chunk 1       Chunk 2              Top Chunk
+-------------+--------------------+------------+
| 0x40        | 0x100              |            |
+-------------+--------------------+------------+
| /bin/sh\x00 | Unimportant data   |            |
+-------------+--------------------+------------+

0xf73ea9 (*__free_hook location)
+-------------+
|             |
+-------------+

tcache[0x100] -> 0xf73ea9
```

Now we allocate another chunk of size `0x100`. The memory at the address of `*__free_hook()` will be used to service this request. So what do we want to put here? We will put the address of the `system()` function here! This now means that when the `free()` function is called, the free hook executes the `system()` function. Further, the `void *ptr` argument of the free hook prototype gets cast to the `const char *command` argument of the system function, meaning that the contents of the freed chunk become the shell command to be executed by `system()`.

```
Chunk 1       Chunk 2              Top Chunk
+-------------+--------------------+------------+
| 0x40        | 0x100              |            |
+-------------+--------------------+------------+
| /bin/sh\x00 | Unimportant data   |            |
+-------------+--------------------+------------+

0xf73ea9 (*__free_hook location)
+-------------+
| 0xe479a2    |
+-------------+

0xe479a2 (system location)
+-------------+
|             |
+-------------+

```

With all this in mind, we can finalise the exploit by deallocating Chunk 1 - deallocation of the chunk results in the `system()` function being executed with argument `/bin/sh\x00`, which is the file path to the shell binary i.e. we should get a shell!

This was a long explanation, but hopefully you now understand how the binary is exploitable.

### Crafting the Exploit

The following python code performs the steps outlines in the above discussion.





