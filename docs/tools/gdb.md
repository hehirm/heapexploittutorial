---
title: "GDB and gef"
layout: default
parent: "Tools"
nav_order: 1
---
## GDB

GDB is the GNU/Linux command line debugger. It is an extremely useful as a debugger for individuals writing programs in C. We will not be using the tool for debugging per-say, but it will be useful to step through binaries and examine the state of the heap. GDB has a wide array of functionality, however we will only look at a limited set that is necessary for our exploits. A useful guide I used to learn GDB when I first started using it was this video - I highly recommend anyone looking to use GDB as a debugger to watch this video as a quick start guide.

### Installation

GDB should come preinstalled on most flavours of Linux. Installation can be verified by running the command `gdb` in a shell.

### Useage

For a binary `my_binary` the command (entered into a shell) to begin a GDB debugging session is:

`> gdb my_binary`

Executing the command should produce the following output:

- [ ] TODO: picture of initial gdb output


GDB uses a command line style interface, where users enter debugging instructions to manipulate the control flow of the current debugging session. The following short list of commands should be sufficient for our purposes:
#### Break

Break points are places where we would like execution of our program to halt, in order for us to examine the current state. To set a break point at the start of a function we can use the command:

```
(gdb) break <function_name>
```

For instance, to set a break point at the beginning of the main function we would use the command:

```
(gdb) break main
```

Often for our purposes we will want to set a breakpoint at a specific address in the program code. To do this we use the `*` character to tell GDB that the argument should be considered as a memory location, not a function name. For instance, setting a breakpoint at the address `0x004009cc` would require us to enter the command:

```
(gdb) break *0x004009cc
```

#### Execution

The program can begin execution by using the `run` command:

```
(gdb) run
```

If any break points have been set, the program will execute until the break point. To continue execution after a break point we use the `continue` command:

```
(gdb) continue
```

As previously stated this is a very limited set of instructions, but these are all that should be necessary from vanilla GDB for the purposes of this tutorial.

## GEF

GEF is a python wrapper for GDB that gives extended functionality for exploit developers. Importantly for us, it provides commands that allow us to explore the current state of the heap.

### Installation

For a quick install, enter the following command into a shell

```
> bash -c "$(curl -fsSL https://gef.blah.cat/sh)"
```

If you are having further issues, refer to the [official install page](https://hugsy.github.io/gef/install/) for assistance.

### Useage

Starting a GDB session as outlined above will now produce a different interface to indicate that GEF is being used:

- [ ] TODO: Insert picture of gef debugging session initialisation

Since this tutorial is concerned with heap exploitation, we will review the commands that examine the state of the heap.

#### Chunks

To examine the currently allocated chunks we can use the `heap chunks` command:

```
gef> heap chunks
```

- [ ] TODO: example output of the heap chunks command

#### Bins

To examine the current state of the bins we can use the `heap bins` command:

```
gef> heap bins
```

- [ ] TODO: example of the output of heap bins

The output of these functions will be discussed in more detail once we start exploiting binaries - for now an awareness of the commands is all that is needed.






