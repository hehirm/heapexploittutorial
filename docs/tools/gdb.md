---
title: "GDB and gef"
layout: default
parent: "Tools"
nav_order: 1
---
# GDB

GDB is the GNU/Linux command line debugger. It is extremely useful as a debugger for programmers using C. We will not be using the tool for debugging per-say, but it will be useful to step through binaries and examine the state of the heap. GDB has a wide array of functionality, however we will only look at a limited set that is necessary for our exploits. A useful guide I used to learn GDB initially was [this video](https://www.youtube.com/watch?v=bWH-nL7v5F4&t=263s) - I highly recommend anyone looking to use GDB as a debugger to watch this video as a quick start guide.

## Installation

GDB should come preinstalled on most flavours of Linux. Installation can be verified by running the command `gdb` in a shell. If it is not installed, the instructions for installation are available [here](https://www.gdbtutorial.com/tutorial/how-install-gdb).

## Useage

For a binary `my_binary` the command (entered into a shell) to begin a GDB debugging session is:

`$ gdb my_binary`

Executing the command should produce the following output:

```
$ gdb my_binary
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from test...
(No debugging symbols found in test)
(gdb)
```

The character `$` will be used to denote input into a shell going forward, to distinguish it from program output. The exception to this is input into GDB, which will be indicated by either the `(gdb)` or `gef>` prompts.

The licensing information can be suppressed by passing the `-q` flag (for quiet) to the start up command:

```
$ gdb -q my_binary
```

GDB uses a command line style interface, where users enter debugging instructions to manipulate the control flow of the current debugging session. The following short list of commands should be sufficient for our purposes:
### Break

Break points are places where we would like execution of our program to halt, in order for us to examine the current state. To set a break point at the start of a function we can use the command:

```
(gdb) break <function_name>
```

For instance, to set a break point at the beginning of the main function we would use the command:

```
(gdb) break main
```

Often for our purposes we will want to set a breakpoint at a specific address in the program code. To do this we use the `*` character to tell GDB that the argument should be considered as a memory location, not a function name. For instance, setting a breakpoint at the address `0x004009cc` would require us to enter the command:

```
(gdb) break *0x004009cc
```

### Execution

The program can begin execution by using the `run` command:

```
(gdb) run
```

If any break points have been set, the program will execute until the break point. To continue execution after a break point we use the `continue` command:

```
(gdb) continue
```

As previously stated this is a very limited set of instructions, but these are all that should be necessary from vanilla GDB for the purposes of this tutorial.

# GEF

GEF is a python wrapper for GDB that gives extended functionality for exploit developers. Importantly for us, it provides commands that allow us to explore the current state of the heap.

## Installation

For a quick install, enter the following command into a shell

```
$ bash -c "$(curl -fsSL https://gef.blah.cat/sh)"
```

If you are having further issues, refer to the [official install page](https://hugsy.github.io/gef/install/) for assistance.

## Useage

Starting a GDB session as outlined above will now produce a different interface to indicate that GEF is being used:

```
$ gdb -q test
GEF for linux ready, type `gef' to start, `gef config' to configure
89 commands loaded and 5 functions added for GDB 12.1 in 0.00ms using Python engine 3.10
Reading symbols from test...
(No debugging symbols found in test)
gef➤
```

Since this tutorial is concerned with heap exploitation, we will review the commands that examine the state of the heap.

### Chunks

To examine the currently allocated chunks we can use the `heap chunks` command:

```
gef➤  heap chunks
Chunk(addr=0x555555559010, size=0x290, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000555555559010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x5555555592a0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x00005555555592a0     3e 20 77 20 6d 75 63 68 20 6d 65 6d 6f 72 79 20    > w much memory ]
Chunk(addr=0x5555555596b0, size=0x410, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x00005555555596b0     33 32 0a 00 00 00 00 00 00 00 00 00 00 00 00 00    32..............]
Chunk(addr=0x555555559ac0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000555555559ac0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x555555559ae0, size=0x30, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000555555559ae0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x555555559b10, size=0x60, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000555555559b10     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x555555559b70, size=0x30, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
    [0x0000555555559b70     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x555555559ba0, size=0x20470, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)  ←  top chunk
```

### Bins

To examine the current state of the bins we can use the `heap bins` command:

```
gef➤  heap bins
──────────────────────────────────────────── Tcachebins for thread 1 ────────────────────────────────────────────
Tcachebins[idx=0, size=0x20, count=1] ←  Chunk(addr=0x5555555592a0, size=0x20, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) 
Tcachebins[idx=4, size=0x60, count=1] ←  Chunk(addr=0x555555559aa0, size=0x60, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) 
───────────────────────────────────── Fastbins for arena at 0x7ffff7e19c80 ─────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
─────────────────────────────────── Unsorted Bin for arena at 0x7ffff7e19c80 ───────────────────────────────────
[+] unsorted_bins[0]: fw=0x5555555592b0, bk=0x5555555592b0
 →   Chunk(addr=0x5555555592c0, size=0x7e0, flags=PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)
[+] Found 1 chunks in unsorted bin.
──────────────────────────────────── Small Bins for arena at 0x7ffff7e19c80 ────────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
──────────────────────────────────── Large Bins for arena at 0x7ffff7e19c80 ────────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
```

The output of these functions will be discussed in more detail once we start exploiting binaries - for now an awareness of the commands is all that is needed.






