---
title: "First Exploit"
layout: default
nav_order: 4
---

# Our First Heap Exploit: Cache Me Outside

### Challenge Description

The first binary we will conduct a heap exploit on comes from the 2021 picoCTF competition. The challenge is titled "Cache Me Outside". The task description reads:

> While being super relevant with my meme references, I wrote a program to see how much you understand heap allocations.

Also included is the command `nc mercury.picoctf.net 49825` which allows us to execute the binary on a remote server, and three files:
- The file `heapedit` contains the binary to exploit.
- The file `Makefile` contains the contents of the Make file used to create the binary.
- The file `libc.so.6` contains the version of libc used to compile the binary.

There is an additional hint which we will use that reads:

> It may be helpful to read a little bit on GLIBC's tcache.

### Initial Observations

Running the provided command gives us the message:

```
You may edit one byte in the program.
Address: 
```

And prompts us to enter an address. After entering the value 100, the program then prompts us to enter a value. Entering 100 again reveals the string:

```
t help you: this is a random string.
```

The Makefile contains the following contents:

``` make
all:
	gcc -Xlinker -rpath=./ -Wall -m64 -pedantic -no-pie --std=gnu99 -o heapedit 
	heapedit.c

clean:
	rm heapedit
```

Of particular interest are the following flags:
- The `-no-pie` flag. This tells the compiler not to make a Position Independent Executable (PIE). A PIE is a requirement to enabling ASLR, so we can infer that the executable is not using ASLR. This should make the challenge a bit easier.
- The `-rpath=./` flag. The rpath specifies the search path that the dynamic linker will use to obtain the required library files. If this doesn't make too much sense right now that is ok - just notice that the linker will be searching the directory that contains `heapedit` for the the libraries (indicated by the `./` file path).

The name of the libc file indicates the version of libc being used: Libc version 6. The libc version determines the heap implementation - this is important information.

Finally the hint indicates that the exploit is going to involve the tcache. We will pay particular attention to the tcache bins when analysing the programs execution.

### Preparing The Local Binary For Analysis


### Understanding the program through decompilation

Disassembling and decompiling the program with Ghidra produces the following output:

- [ ] TODO: Insert Ghidra Output

From the Ghidra output we can see that the program:
- Reads the flag in from a file
- Performs 7 identical heap allocations
- Performs another heap allocation, although different from the first 7
- Reads in the location and value of the byte to be changed
- Makes the necessary byte adjustment
- Allocates another chunk of memory, which is used to display some output

This gives us a clearer idea of how the program is working, at least generally. Before moving on it is worthwhile paying attention to how the user input actually manipulates the program. This is done by the line:

``` C
*(undefined *) ((long)local_a8 + (long)local_a0) = local_a9
```

Using the program context, `local_a8` and `local_a9` are respectively the address and value entered by the user. Less clear is the value of `local_a0`. Looking back through the main function, `local_a0` is initially set to 0 before being set to equal the address returned by the first call to malloc in the 7 identical allocations. In this sense then, the value of `local_a8` is actually an *offset* from this memory location, as opposed to a program address. As such, we will now refer to it as an offset.

The Ghidra output is also useful for obtaining key memory addresses to set breakpoints at. Selecting a line in the decompiled output reveals the address of the corresponding assembly instruction in the disassembled output.

- [ ] TODO: Insert picture to illustrate this point

While I encourage you to try a variety of addresses, for the purposes of this explanation we will choose the following addresses. 
- 0x004009a3 corresponding to the line `free(local_98)`
- 0x004009cc corresponding to the line `puts("You may edit one byte in the program");`
- 0x00400a5e corresponding to the line `puts((char *)((long)local_80 +0x10));`

- [ ] TODO: Insert picture of this particular output

### Finding the Vulnerability

Lets now execute the binary with GDB by typing the command `gdb heapedit`. This will start an interactive debugging session, indicated by the `gef>` prompt (note that this tutorial requires the gef wrapper for GDB to be installed). We will use this to examine how the program is manipulating memory, allowing us to find the vulnerability.

The first thing we need to do is set some breakpoints. The first will be set at the start of the main program and can be done by entering `break main` into the gef prompt (you need to press enter after all of these commands). The second will be set at the addresses found in the previous section. This can be done by entering the command `break *adr` where adr is replaces by the address for the break point to be set at (for example the command `break *0x004009cc` will set a breakpoint at the address 0x004009cc). Your prompt should now look as follows.

- [ ] TODO: insert picture of break point output

We can now begin the program by entering `run` which immediately halts our program at the first breakpoint in our program, located at the top of the main function. We can explore the content of the heap bins by entering `heap bins` into the gef prompt - the output indicates that no calls to free have been made yet. We can also obtain information about heap chunks by typing `heap chunks` - here it produces an error as no chunks have been allocated yet.

- [ ] TODO: Insert picture of this output

We can now resume execution by typing `continue` which takes us to the next breakpoint, set after allocating the flag buffers and the dummy buffer. Taking a look at the chunks reveals the following layout:

- [ ] Insert picture

The output shows 8 chunks of size 0x90, of which 7 of these contain the partial contents "Congrats! Your f" - these chunks are almost certainly our flag buffers. The final chunk of size 0x90 has contents "Sorry! This won" and is thus going to be our dummy buffer. First three chunks in the output are related to reading in the flag and the bottom chunk is (paradoxically) the top chunk. We will only be concerned with the chunks containing the flag and dummy buffers.

Resuming execution with `continue` takes us to the breakpoint after the dummy buffer and one of the flag buffers have been freed. Inspecting the bins with `heap bins` now reveals that the tcache contains two chunks of size 0x90, with addresses 0x603800 and 0x603890. 


- [ ] TODO: Insert picture of this output


We can use `heap chunks` to determine which is the dummy buffer and which is a flag buffer. 

- [ ] TODO: Insert Picture of this output

So 0x603800 is the address of the flag buffer and 0x603890 is the address of the dummy buffer. We also have further evidence that these chunks are no longer allocated as the start of their data segments have been overwritten, likely with data for managing the tcache.

Recall that the tcache is an array containing pointers to linked lists which contain freed chunks of the same size. Since both the flag buffer and the dummy buffer have size 0x90 they are added to the same linked list.

We now `continue` execution to our final breakpoint - after the final memory allocation. Note that in order to reach this breakpoint the program will ask you to enter the location and value details of the byte modification. Inspecting the heap bins reveals only one chunk in the tcache bin, which corresponds to the flag buffer. The other chunk has been used to service the malloc request, since the request for a chunk of size 0x90 which was readily available in the tcache. Since the memory is unmodified after being allocated, printing its contents reveals the contents of the dummy buffer:

- [ ] TODO: Show output of program

Observe that if instead the chunk containing the flag buffer had been used to service the final call to malloc, then the final output would likely contain our flag. Lets see how this might be possible by looking at the setup of the tcache right before the final memory allocation:

```
  tcache array       0x603890            0x603800
+--------------+    +--------------+    +-------------+
| 0x603890     | -> | Dummy Buffer | -> | Flag Buffer |
+--------------+    +--------------+    +-------------+
|              |
+--------------+
      ...
+--------------+
|              |
+--------------+
```

Without attacker intervention, if the tcache can service a malloc request, it will always use the first chunk available. For us this is the chunk containing the dummy buffer, as it is freed after the chunk containing the flag buffer. Importantly, the only way the tcache knows which chunk is "first" is by the pointer value stored in the tcache array, which in this case is 0x603890. Changing this pointer value to contain the address of the chunk containing the flag buffer would result in that chunk being used to service the malloc request and the subsequent revealing of the flag. 

```
  tcache array       0x603800            0x603890
+--------------+    +--------------+    +--------------+
| 0x603800     | -> | Flag Buffer  | <- | Dummy Buffer |
+--------------+    +--------------+    +--------------+
|              |
+--------------+
      ...
+--------------+
|              |
+--------------+
```

This is promising, but how do we overwrite the address in the tcache array? Observe that the addresses of the chunks for the flag buffer and dummy buffer only differ in the second last hexadecimal digit (one has a 9 while the other has a 0). Thus modifying the last two digits of the tcache array value from 90 to 00 would be sufficient to have the tcache array point to the flag buffer chunk. But two digits of a hexadecimal value encodes one byte, and the program allows us to modify the contents of any single byte. If we can find out where this byte is in memory, we should be able to use the program to modify its contents and retrieve the flag!

### Finding the location of the byte

Restart the program with gdb (`gdb heapedit`) and set a breakpoint at 0x4009cc (`break *0x4009cc`). Recall that this is after the two chunks have been freed, but before the final memory allocation, meaning the tcache array contains a pointer to (or the address of) the flag buffer. We would like to find where in memory this pointer is being stored, so we can overwrite it. To do this we enter the command `search-pattern 0x603890` into gdb, which produces the following output:

```
gef> search-pattern 0x603890
[+] Searching '\x90\x38\x60' in memory
[+] In '[heap]'(0x602000-0x623000), permission=rw-
  0x602088 - 0x602094  →   "\x90\x38\x60[...]"
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rw-
  0x7fffffffe240 - 0x7fffffffe24c  →   "\x90\x38\x60[...]"
```

We will ignore the stack part, as we know that the location we are after is in the heap. We can interpret the heap output information as meaning our pointer starts at address 0x602088. As it turns out, this is actually the precise memory location of our target byte `\x90`,  as indicated by the contents between the quotations. This reversal of the address is due to our binary being *little endian*, essentially meaning that the least significant byte is stored at the lowest memory address (we won't discuss this further, there are ample pre existing resources on the topic).

This address is not quite sufficient, as the Ghidra decompilation showed us the address was actually being used as an *offset* from the address from the first flag buffer chunk allocated. Looking back through our gdb outputs, we can see that the address of this chunk is 0x6034a0. Thus the offset can be computed as:

$$ \text{0x602088} - \text{0x6034A0} = -5144$$
### Crafting the exploit

Let us now write a simple pwntools script to pwn this binary!

``` python
from pwn import *

def conn():
	if args.LOCAL:
		r = process([ELF("./heapedit").path])
	else:
		r = remote("nc mercury.picoctf.net", 8054)
	return r

def main():
	r = conn()
	r.recvuntil(b"Address: ")
	r.send(b"-5144\n")
	r.recvuntil(b"Value: ")
	r.send(p64(0))
	r.interactive()

if __name__ == "__main__":
	main()
```

Lets look at some key parts of the script:
- The script imports all functions from the pwntools `pwn` library
- The `conn()` function sets up the binary, which can be either remote or local depending on the arguments specified.
- The main function executes until the "Address: " line is produced by the program.
