---
title: "Heap Mechanics Part 1: Allocation"
layout: default
nav_order: 2
parent: Heap Introduction
---

# Heap Mechanics Part 1: Allocation

As discussed previously, the heap is necessarily complex as a result of the flexibility it affords. It is the goal of this section to familiarise you with this complexity. The upfront cost of learning how the heap works will pay its dividends, as the heap is ripe with potential avenues for exploitation.

The first part will introduce you to the fundamental ideas in allocation. The second part will introduce deallocation.

### Different Heap Implementations

There are many different implementations of the heap: the heap used by the Android OS is different to the one used by Windows, which is different again to the one used by Linux. We will be focusing on the glibc implementation of the heap i.e. the heap used by Linux. This is because many CTFs use this heap, and the code is open source i.e. freely available to inspect and analyse.

Even within glibc, there are multiple different versions that have different features. This is most evident in glibc versions pre and post 2.26, which saw the introduction of the tcache bins (don't worry if you don't know what this is right now). The high level discussion means that this description should fit most semi-recent glibc implementations. The attacker should pay attention to version specific vulnerabilities when exploiting binaries.
### Memory Allocation

The heap begins its life as one large contiguous piece of memory.

```
low address                                         high address
+--------------------------------------------------------------+
|                                                              |
|                                                              |
+--------------------------------------------------------------+
```

When the program requests memory using the `malloc()` function, this contiguous segment is partitioned in two. The first part is a section of memory containing a number of bytes slightly larger than the number of bytes specified by the `malloc()` argument. We call this section of memory a **heap chunk**, or simply a chunk if the context is unambiguous. This memory has now been allocated by the heap to the program - the pointer returned by `malloc()` points to this chunk. The second part of the partition contains unallocated memory. As it turns out this region of memory is also a chunk, although it has a special name: the **top chunk**.

```
low address                                         high address
+--------------------------------------------------------------+
| Allocated | Top                                              |
| Chunk     | Chunk                                            |
+--------------------------------------------------------------+
```

The process is very similar for further allocations - the top chunk gives away enough memory to satisfy the request (always from the bottom) thereby reducing its own size in the process.

```
low address                                         high address
+--------------------------------------------------------------+
| Allocated | Allocated | Allocated | Top                      |
| Chunk     | Chunk     | Chunk     | Chunk                    |
+--------------------------------------------------------------+
```

### Chunks

Let's take a look at chunks in more detail, as they are the key constituents of the heap. We stated before that a chunk contains a number of bytes slightly larger than the amount requested. This is for a few reasons:
- The minimum size for a chunk is 32 bytes, or 0x20 in hexadecimal. This is because chunks need to store certain information once they have been deallocated, and 0x20 is the minimum amount of space required to store this data.
- The size of a chunk must be a multiple of 16 bytes, to ensure that the all of the chunks are 16 byte aligned. This alignment results in significant performance optimisations for allocations of large data structures. This means that the size expressed in hexadecimal will always end in a 0.
- Chunks have a certain amount of space reserved for metadata. This is known as the **chunk header** or header, and is positioned just before the actual contents of the chunk. The size of this field is 8 bytes on x64 architectures. The chunk header contains 4 pieces of information:
	- A `PREV_INUSE` flag indicating if the previous chunk is currently allocated.
	- An `IS_MMAPED` flag indicating if the chunk was large enough to be allocated off heap. We will not be discussing this aspect of the heap, as it only pertains to really large chunks (assume it is not set).
	- A `NON_MAIN_ARENA` flag indicating if the chunk is in the main arena or not. The concept of arenas comes up when dealing with multithreaded programs, and will not be discussed here (assume it is not set).
	- The size of the chunk.
	Since the chunk size is a multiple of 16 bytes, the lowest four bits will always be zero. This means that the lowest three of these bits can be used for the other three flags. The chunk size can then effectively use all 8 bytes to represent the size.

Let us take a look at some chunk allocation examples. Consider the following program:

``` C
#include <stdlib.h>

int main() {
	char *ptr1 = (char *) malloc((size_t) 40);
	char *ptr2 = (char *) malloc((size_t) 35);
	char *ptr3 = (char *) malloc((size_t) 8);
	free(ptr1);
	free(ptr2);
	free(ptr3);
	return 0;
}
```

First call to malloc asks for 40 bytes of memory. Since 8 bytes are required for the chunk header, the minimum size of the chunk is 48 bytes. Since 48 = 3 * 16, this will in fact be the chunk size. The `PREV_INUSE` bit will be set in this case, as there is no previous chunk (the memory is most definitely being used). Assuming the heap starts at address `0x100008`, and the top chunk initially contains `0x999990` bytes, we have the following layout for our heap currently:

```
         |      .....      |
         +-----------------+
0x100038 | 0x999961        | Top chunk
         +-----------------+
         |                 |
         |                 |
         |                 |
         |                 |
         |                 |
         +-----------------+
0x100008 | 0x31            | First chunk allocated
         +-----------------+
```

There are a couple of things to make note of here:
- Each value in the chunk header field ends in a 1. This indicates that the `PREV_INUSE` flag/bit is enabled.
- The remaining part of the value in the chunk header corresponds to the chunk size. The allocated chunk has size 0x30 which equals 48 in decimal. The top chunk has size 0x999960, which is 0x30 less than its starting size, since this is the amount of memory given away for the allocation.
- The choice of `0x100008` for the starting address was not completely arbitrary - a value of 8 for the least significant digit ensures that the actual contents of the chunk fall on an address that is a multiple of 16. This is what is mean by 16 byte alignment.

Now lets look at the second allocation, which asks for 35 bytes of memory. Again, factoring in the chunk header size the minimum size for this chunk is 43. Since the size needs to be a multiple of 16, we round up to the nearest multiple which is 48. The `PREV_INUSE` bit will be set as the first chunk is still allocated.

```
         |      .....      |
         +-----------------+
0x100068 | 0x999931        | Top chunk
         +-----------------+
         |                 |
         |                 |
         |                 |
         |                 |
         |                 |
         +-----------------+
0x100038 | 0x31            | Second chunk allocated
         +-----------------+
         |                 |
         |                 |
         |                 |
         |                 |
         |                 |
         +-----------------+
0x100008 | 0x31            | First chunk allocated
         +-----------------+
```

The last allocation requires 8 bytes for data, so including the header 16 bytes are required in total. This is a multiple of 16, however it is smaller than the minimum chunk size which is 32 bytes, meaning that the minimum chunk size is allocated. The `PREV_INUSE` flag is set as the second chunk is still allocated at this stage.

```
         |      .....      |
         +-----------------+
0x100088 | 0x999911        | Top chunk
         +-----------------+
         |                 |
         |                 |
         |                 |
         +-----------------+
0x100068 | 0x21            | Third chunk allocated
         +-----------------+
         |                 |
         |                 |
         |                 |
         |                 |
         |                 |
         +-----------------+
0x100038 | 0x31            | Second chunk allocated
         +-----------------+
         |                 |
         |                 |
         |                 |
         |                 |
         |                 |
         +-----------------+
0x100008 | 0x31            | First chunk allocated
         +-----------------+
```

There are a few remaining discussion points for allocation:
- The OS determines the initial size for the heap. If the top chunk becomes to small to service a malloc request, it can request for more memory from the OS. If the OS cannot provide any more memory, to the heap then the request fails (this is why it is important to always check the return value of malloc). In the next section we will look at how chunks are recycled once they are deallocated which assists malloc in servicing requests.
- Some sources will say that the chunk header size is 16 bytes. This is because the last 8 bytes of freed chunks are repurposed to store metadata for the next chunk. Since chunks are not always in a freed state I have not included this section in my definition of a header.



https://faraz.faith/2019-10-12-picoctf-2019-heap-challs/#sice_cream