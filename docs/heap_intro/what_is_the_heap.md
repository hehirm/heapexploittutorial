---
title: What is the Heap?
layout: default
nav_order: 1
parent: Heap Introduction
---

# What is the Heap?
### Contextualising

Executing a binary file creates a process which is an operating system abstraction to store the important aspects about a running program. Among other things, a process creates a virtual address space which maps on to the computers physical memory. The virtual address space allows programmers to think about program memory as a contiguous block, without any knowledge of the underlying hardware. This contiguous block can be divided into segments, each performing a particular role. The following diagram shows the typical layout of an x64 linux process address space:

```
Low Memory Addresses                               High Memory Addresses
+------+------+-----+------+---------+---------------+---------+-------+
| text | data | bss | heap | ->      | mmaped region |      <- | stack |
+------+------+-----+------+---------+---------------+---------+-------+
```

The **heap** is one of the segments in this contiguous block. Together with the **stack** segment, they are the only regions that change size over the lifetime of the program. This makes them prime targets for exploitation, as vulnerabilities arise from the complexity of dynamic data structures.

Counterintuitively, we will begin looking at the stack, as it will help highlight the specific goals the heap is trying to accomplish.
### The Stack

The stack is a relatively simple data structure. It is a Last In First Out (LIFO) data structure, meaning the most recent item to join the stack is the first item to be removed from the stack. I usually have a stack of plates in my mind when thinking about the stack - the first plate to be pulled off should be the one on top i.e. the plate most recently added. The relevant operations for adding and removing items from the stack are push and pop.

A process uses the stack to manage function calls though the use of **stack frames**. A stack frame contains the following key pieces of information:
- Parameters: These are the values passed to the function.
- Return Address: Once the function has completed, the return address tells the program where to continue execution.
- Local Variables: These are the variables defined within the scope of the function.

Lets consider a simple example program:

```
#include <stdio.h>

int foo(int value) {
	int multiplier = 2;
	int ret;
	ret = value * multiplier;
	return ret;
}

int main() {
	char my_array[4];
	int my_int;
	int return_value;
	my_int = 4;
	return_value = foo(my_int);
	return 0;
}
```

The program starts at the main function, meaning that a stack frame for the main function is created and pushed onto the process stack. This stack frame contains no parameters (as none were passed), a return address determined by the operating system (as when main returns the program returns control to the OS) and the local variables `my_array`, `my_int` and `return_value`. The main function calls the function `foo`, which gets its own stack frame pushed to the stack. This stack frame contains the parameter `value`, the return address of the appropriate line in the main function and local variables `multiplier` and `ret`. This stack frame is popped off the stack once the function `foo` returns.

The stack is extremely useful for the following reasons:
- Using the stack is **implicit** - pushing and popping stack frames occurs without the programmer needing to think about it.
- It is **simple** and **fast**. Once a function finishes, the associated memory is no longer needed and can be removed immediately.

The primary disadvantage of the stack is **inflexibility**. This manifests in two ways:
-  Memory is **impersistent** between function calls. For instance the `multiplier` variable in `foo` cannot be accessed once the function has returned.
- The **amount of memory must determined at compile time**. For instance the array `my_array` can store a maximum of 4 bytes - if we want to store more data we must change the size of the array before the program is compiled.

### The Heap

Let us now look at the heap. The heap seeks to improve on the stacks lack of flexibility. The general usage of the heap is relatively streamlined:
- A running process requests a certain amount of memory from the heap using the `malloc()` function. The function prototype for `malloc()` is:

```
void * malloc(size_t size);
```

   The function takes a single parameter `size` which specifies the number of bytes required. The function returns a pointer to the starting location of the reserved memory.
- Once finished with the memory, the process tells the heap to free the memory it allocated, using the function `free()`. The function prototype for `free()` is: 
 
```
void free(void *ptr)
```

   This function also takes a single parameter `ptr` which is a pointer to the region of memory to be deallocated (this pointer should be the return value from a prior call to `malloc()`). Once `free()` has been called the memory is no longer reserved and can be used for other memory requests.

The functions `malloc()` and `free()` are contained in the C standard library (libc) and are located in the memory mapped region of a process. The following simple program demonstrates an example usage of the functions:

``` C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *my_string = (char *) malloc(14 * sizeof(char));
    strncpy(my_string, "Hello, World!\0", 14);
    printf("%s\n", my_string);
    free(my_string);
    return 1;
}
```

The first line of the main function requests memory from the heap using the malloc function:
- The `(char *)` before the function call is a type cast. `malloc` has no awareness of the type of data being stored, so this part explicitly indicated that the returned pointer will be to data of `char` type.
- The `malloc` function takes `14 * sizeof(char)` as its argument, which is 14 bytes.
- The return value of malloc is stored in a pointer of type `char*`, which is a reference to the allocated 14 bytes.

The second line copies the string `"Hello, World!\0"` into the memory allocated by the heap. The string contains 13 readable characters, and a terminating null byte. After printing the string in the third line, the program then deallocates the memory it allocated previously by passing the pointer `my_string` to the function `free()`.

This is a rather trivial example that could just as easily have been implemented on the stack. However, for much larger applications having the ability to allocate and deallocate memory as required makes the heap **flexible**:
- A process can request an amount of memory determined by a variable, the value of which may not be known until run time.
- A process can maintain a memory reservation through function calls - the memory only becomes deallocated when the `free()` function is called.

However flexibility comes at a cost:
- The user needs to be **explicit** in how memory is allocated and deallocated. Any novice (or advanced for that matter) C programmer can attest to the frustration induced by common memory bugs associate with using `malloc()` and `free()` incorrectly. This is not something that the compiler will handle. 
- The heap is **slow**, or at least could be slow. In fact the heap is relatively fast, at the cost of **complexity**. 

It is both the complexity and the reliance on the programmer to use the heap functions correctly that makes the heap prone to many different types of exploits.