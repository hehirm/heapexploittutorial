---
title: Home
layout: default
nav_order: 1
---

# The virtual address space

Recall that executing a binary file creates a *process* which is an operating system abstraction to store all important aspects about a running program. Among other things, a process creates a *virtual address space* which maps on to the computers physical memory. The virtual address space allows programmers to think about the memory of a running program as a contiguous block of memory. The following diagram shows the typical layout of an x86 linux process address space


```
Low Memory Addresses                               High Memory Addresses
+------+------+-----+------+---------+---------------+---------+-------+
| text | data | bss | heap | ->      | mmaped region |       <-| stack |
+------+------+-----+------+---------+---------------+---------+-------+
```

#### Text

The text segment, also called the code segment, stores the program instructions and constant variables. It is a read only area of memory.

#### Data

The data segment is a read/write area of memory that stores initialised static variables i.e. those marked with the `static` keyword.

#### BSS

The BSS segment is similar to the data segment, except the static variables are uninitialised.

#### Heap

The heap segment stores dynamically allocated memory i.e. memory allocated at run time. As the heap increases in size it grows upwards (towards higher memory addresses) as indicated by the arrow. The heap is the central area of this discussion and will be discussed in great depth.
#### Mmaped region

The memory mapped region stores direct byte for byte mappings within the virtual memory space. This results in a significant performance speed up, as the process is not required to make a system call to access the contents of the file. Typically this is where the C library functions are stored, contained in the libc file.

#### Stack

The stack segment contains the function call stack, which is responsible for keeping track of function calls and local variables. As more data is added to the stack it grows downwards (towards lower memory addresses) indicated by the arrow.

# What is the heap?

### Stack vs Heap

To help illustrate the power of the heap, we will consider the limitations of the stack.

The stack is a Last In First Out data structure, making it ideal for dealing with function calls. The stack primarily works with stack frames, which contain any parameters passed to the function call, references to local variables used by the called function and a return address - the place the function should return to once it has finished. As functions are called these stack frames are pushed on to the stack. The top of the stack always contains the currently executing function, and each subsequent stack frame represents the function that created the stack frame above it. Since the stack adheres to a LIFO structure, removing elements from the stack retraces the function call pattern.

A running process always keeps a reference to the top of the stack, meaning that determining the location to push the next stack frame is incredibly fast. Further, since all the information required to create and push the stack frame is contained in the process, this operation can be performed automatically (this is done by the operating system managing the process). Also, since the size of all the data contained in a stack frame is known at compile time, the size of the stack is fixed at runtime.

Consider the task of the humble web browser: it must hold multiple tabs open at once and support arbitrarily opening, closing and switching between them. Using a stack, each new tab opened gets pushed onto the stack in the desired data structure. Switching between tabs requires rearranging the contents of the stack so the tab to be open exists at the top of the stack - this is a costly operation. Similarly, deleting a tab requires modifying the layout of the stack which is again costly.


# What is the heap segment

The heap segment is responsible for storing dynamic memory allocations made my the program i.e. allocations determined at run time. On the surface the process is simple
- The running process requests a certain amount of memory from the heap which the heap finds and returns to the process through a pointer to the memory location. This is achieved by calling the function `malloc()`.
- Once finished with the memory, the process tells the heap to free the memory it allocated, specifying the address to tell the heap which memory is no longer needed. This is achieved by calling the function `free()`.

The functions `malloc()` and `free()` are located in the C standard library (libc) and are located in the memory mapped region of the process. The following simple program demonstrates an example usage of the function:

``` C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char *my_string = (char *) malloc(14 * sizeof(char));
    strncpy(my_string, "Hello, World!", 14);
    printf("%s\n", my_string);
    free(my_string);
    return 1;
}
```

The first line of the main function requests memory from the heap using the malloc function:
- The `(char *)` before the function call is a type cast. `malloc` has no awareness of the type of data being stored, so this part explicitly indicated that the returned pointer will be to data of `char` type.
- The `malloc` function takes a single argument, which is the number of bytes required. In this case we are requesting 14 bytes, as `sizeof(char)` is 1 (byte).
- The output of malloc is stored in a pointer of type `char*`. This pointer contains the address in the heap where the memory has been allocated.

The second line copies the string `"Hello, World!"` into the memory allocated by the heap. The string contains 13 readable characters, and a terminating null byte. After printing the string in the third line, the function then deallocated the memory it allocated in the first line, by passing the address of the allocated memory (the address stored in the pointer `my_string`) to the function `free()`.

This is a rather trivial example that could have just as easily have been implemented on the stack. However, for much larger applications having the ability to allocate and deallocate memory as required is extremely useful.

# How the heap works

Since the heap is used so often, it is of critical importance that it is as fast as possible. Unlike the stack which is straight forward to understand, the heap is quite complex. Understanding the heap at least partially will help in the coming sections where we exploit it. The rest of this section will be devoted to understanding how the heap works.




# Our First Heap Exploit: Cache Me Outside

### Challenge Description

The first binary we will conduct a heap exploit on comes from the 2021 picoCTF competition. The challenge is titled "Cache Me Outside". The task description reads:

> While being super relevant with my meme references, I wrote a program to see how much you understand heap allocations.

Also included is the command `nc mercury.picoctf.net 49825` which allows us to execute the binary on a remote server, and three files:
- The file `heapedit` contains the binary to exploit.
- The file `Makefile` contains the contents of the Make file used to create the binary.
- The file `libc.so.6` contains the version of libc used to compile the binary.

There is an additional hint which we will use that reads:

> It may be helpful to read a little bit on GLIBC's tcache.

### Initial Observations

Running the provided command gives us the message:

```
You may edit one byte in the program.
Address: 
```

And prompts us to enter an address. After entering the value 100, the program then prompts us to enter a value. Entering 100 again reveals the string:

```
t help you: this is a random string.
```

The Makefile contains the following contents:

``` make
all:
	gcc -Xlinker -rpath=./ -Wall -m64 -pedantic -no-pie --std=gnu99 -o heapedit 
	heapedit.c

clean:
	rm heapedit
```

Of particular interest are the following flags:
- The `-no-pie` flag. This tells the compiler not to make a Position Independent Executable (PIE). A PIE is a requirement to enabling ASLR, so we can infer that the executable is not using ASLR. This should make the challenge a bit easier.
- The `-rpath=./` flag. The rpath specifies the search path that the dynamic linker will use to obtain the required library files. If this doesn't make too much sense right now that is ok - just notice that the linker will be searching the directory that contains `heapedit` for the the libraries (indicated by the `./` file path).

The name of the libc file indicates the version of libc being used: Libc version 6. The libc version determines the heap implementation - this is important information.

Finally the hint indicates that the exploit is going to involve the tcache. We will pay particular attention to the tcache bins when analysing the programs execution.

### Preparing The Local Binary For Analysis

----

[^1]: [It can take up to 10 minutes for changes to your site to publish after you push the changes to GitHub](https://docs.github.com/en/pages/setting-up-a-github-pages-site-with-jekyll/creating-a-github-pages-site-with-jekyll#creating-your-site).

[Just the Docs]: https://just-the-docs.github.io/just-the-docs/
[GitHub Pages]: https://docs.github.com/en/pages
[README]: https://github.com/just-the-docs/just-the-docs-template/blob/main/README.md
[Jekyll]: https://jekyllrb.com
[GitHub Pages / Actions workflow]: https://github.blog/changelog/2022-07-27-github-pages-custom-github-actions-workflows-beta/
[use this template]: https://github.com/just-the-docs/just-the-docs-template/generate
